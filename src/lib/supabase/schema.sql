-- Users table
CREATE TABLE IF NOT EXISTS users (
  id uuid PRIMARY KEY REFERENCES auth.users, -- Link to Supabase Auth
  email TEXT UNIQUE NOT NULL,
  name TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  last_login TIMESTAMP WITH TIME ZONE
);

-- Assessment sessions
CREATE TABLE IF NOT EXISTS assessment_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id),
  use_case TEXT NOT NULL, -- major_selection, career_change, couples_compatibility, team_dynamics
  status TEXT DEFAULT 'in_progress', -- in_progress, completed, expired
  payment_status TEXT DEFAULT 'pending', -- pending, paid, refunded
  
  -- Multi-participant (Updated for Couples/Teams)
  share_code VARCHAR(6), -- Not UNIQUE here anymore, as multiple members share the code
  session_type VARCHAR(20) DEFAULT 'individual', -- 'individual', 'couple', 'team'
  parent_session_id UUID REFERENCES assessment_sessions(id), -- For team members linking to leader
  participant_role VARCHAR(20), -- 'initiator', 'partner', 'member', 'leader'
  participant_name VARCHAR(100),
  team_id UUID, -- FK to team_sessions if I add it, or we rely on parent_session_id. Let's add explicit FK for cleanliness if possible, but circular deps might be an issue if team_sessions refs assessment_sessions. 
  -- Actually, let's keep it simple: parent_session_id is enough for linking. 
  -- Or link to `team_sessions(id)`. Let's add `team_group_id UUID` later if needed.
  -- For now, `share_code` links them conceptually.
  
  -- Results storage
  results_token UUID UNIQUE DEFAULT gen_random_uuid(), -- For public access
  mbti_type TEXT,
  mbti_scores JSONB, -- JSON: {EI: 5, SN: -3, TF: 10, JP: -8}
  holland_code TEXT,
  holland_scores JSONB, -- JSON: {R: 5, I: 12, A: 8, S: 3, E: -2, C: 1}
  big_five_scores JSONB,
  work_values_scores JSONB,
  attachment_style TEXT,
  attachment_scores JSONB, 
  love_languages_scores JSONB, 
  strengths_scores JSONB, 
  eq_scores JSONB, 
  conflict_style TEXT,
  conflict_scores JSONB, 
  
  -- AI analysis
  ai_analysis TEXT,
  
  -- Validity
  response_quality_score INTEGER,
  validity_flags JSONB, -- JSON array of flags
  
  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  started_at TIMESTAMP WITH TIME ZONE,
  completed_at TIMESTAMP WITH TIME ZONE
  
  -- Removed UNIQUE(share_code) constraint
);

-- Couples specific
CREATE TABLE IF NOT EXISTS couple_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  share_code VARCHAR(6) UNIQUE NOT NULL,
  initiator_session_id UUID REFERENCES assessment_sessions(id),
  partner_session_id UUID REFERENCES assessment_sessions(id),
  status VARCHAR(20) DEFAULT 'waiting_partner', -- 'waiting_partner', 'waiting_payment', 'completed'
  payment_id BIGINT REFERENCES payments(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  expires_at TIMESTAMP WITH TIME ZONE DEFAULT (now() + interval '7 days')
);

-- Team specific
CREATE TABLE IF NOT EXISTS team_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  share_code VARCHAR(6) UNIQUE NOT NULL,
  leader_session_id UUID REFERENCES assessment_sessions(id),
  team_name TEXT NOT NULL,
  status VARCHAR(20) DEFAULT 'collecting', -- 'collecting', 'analyzing', 'completed'
  payment_id BIGINT REFERENCES payments(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  expires_at TIMESTAMP WITH TIME ZONE DEFAULT (now() + interval '30 days')
);

-- User answers (for detailed analysis)
CREATE TABLE IF NOT EXISTS user_answers (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id UUID NOT NULL REFERENCES assessment_sessions(id),
  question_id TEXT NOT NULL,
  assessment_type TEXT NOT NULL,
  answer_value INTEGER NOT NULL, -- -2 to +2
  response_time_ms INTEGER, -- Time to answer in milliseconds
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Payments
CREATE TABLE IF NOT EXISTS payments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  session_id UUID NOT NULL REFERENCES assessment_sessions(id),
  user_id UUID NOT NULL REFERENCES users(id),
  amount DECIMAL(10,2) NOT NULL,
  currency TEXT DEFAULT 'SAR',
  status TEXT DEFAULT 'pending', -- pending, paid, failed, refunded
  payment_method TEXT, -- mada, visa, mastercard, applepay, stcpay
  transaction_no TEXT, -- Moyasar invoice ID
  order_number TEXT UNIQUE, -- Our internal order ID
  moyasar_payment_id TEXT,
  customer_name TEXT,
  customer_mobile TEXT,
  paid_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Audit log
CREATE TABLE IF NOT EXISTS audit_log (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID,
  action TEXT NOT NULL,
  resource_type TEXT,
  resource_id TEXT,
  details JSONB,
  ip_address TEXT,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Complaints
CREATE TABLE IF NOT EXISTS complaints (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  mobile TEXT NOT NULL,
  order_number TEXT,
  complaint_type TEXT NOT NULL,
  details TEXT NOT NULL,
  status TEXT DEFAULT 'pending', -- pending, in_progress, resolved
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  resolved_at TIMESTAMP WITH TIME ZONE
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON assessment_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_sessions_share_code ON assessment_sessions(share_code);
CREATE INDEX IF NOT EXISTS idx_sessions_results_token ON assessment_sessions(results_token);
CREATE INDEX IF NOT EXISTS idx_sessions_status ON assessment_sessions(status);
CREATE INDEX IF NOT EXISTS idx_answers_session_id ON user_answers(session_id);
CREATE INDEX IF NOT EXISTS idx_payments_session_id ON payments(session_id);
CREATE INDEX IF NOT EXISTS idx_audit_user_id ON audit_log(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_created_at ON audit_log(created_at);

-- RLS Policies (Basic)
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE assessment_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_answers ENABLE ROW LEVEL SECURITY;
ALTER TABLE payments ENABLE ROW LEVEL SECURITY;

-- Users can read their own data
CREATE POLICY "Users can read own data" ON users FOR SELECT USING (auth.uid() = id);

-- Sessions: Users can read their own sessions
CREATE POLICY "Users can read own sessions" ON assessment_sessions FOR SELECT USING (auth.uid() = user_id);
-- Sessions: Users can insert their own sessions
CREATE POLICY "Users can insert own sessions" ON assessment_sessions FOR INSERT WITH CHECK (auth.uid() = user_id);
-- Sessions: Public read access via share_code (for joining) - Needs careful logic, maybe specialized function
-- For now, open read for participant logic will be handled via server-side admin client or specific RPCs.
